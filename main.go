package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"time"

	"github.com/gorilla/mux"
)

func main() {

	r := mux.NewRouter()

	r.HandleFunc("/api/uploadfood", PostFoodHandler).Methods("POST")

	server := &http.Server{
		Addr:    ":8080",
		Handler: r,
	}
	server.ListenAndServe()

	log.Println("Server ending...")
}

type AutoGenerated struct {
	FoodFamily []struct {
		ID   int     `json:"id"`
		Name string  `json:"name"`
		Prob float64 `json:"prob"`
	} `json:"foodFamily"`
	FoodType struct {
		ID   int    `json:"id"`
		Name string `json:"name"`
	} `json:"foodType"`
	ImageID       int `json:"imageId"`
	ModelVersions struct {
		Drinks       string `json:"drinks"`
		FoodType     string `json:"foodType"`
		Foodgroups   string `json:"foodgroups"`
		Foodrec      string `json:"foodrec"`
		Ingredients  string `json:"ingredients"`
		Ontology     string `json:"ontology"`
		Segmentation string `json:"segmentation"`
	} `json:"model_versions"`
	Occasion            string `json:"occasion"`
	SegmentationResults []struct {
		Center struct {
			X int `json:"x"`
			Y int `json:"y"`
		} `json:"center"`
		ContainedBbox struct {
			H int `json:"h"`
			W int `json:"w"`
			X int `json:"x"`
			Y int `json:"y"`
		} `json:"contained_bbox"`
		FoodItemPosition   int `json:"food_item_position"`
		RecognitionResults []struct {
			FoodFamily []struct {
				ID   int    `json:"id"`
				Name string `json:"name"`
			} `json:"foodFamily"`
			FoodType struct {
				ID   int    `json:"id"`
				Name string `json:"name"`
			} `json:"foodType"`
			ID         int     `json:"id"`
			Name       string  `json:"name"`
			Prob       float64 `json:"prob"`
			Subclasses []struct {
				FoodFamily []struct {
					ID   int    `json:"id"`
					Name string `json:"name"`
				} `json:"foodFamily"`
				FoodType struct {
					ID   int    `json:"id"`
					Name string `json:"name"`
				} `json:"foodType"`
				ID   int     `json:"id"`
				Name string  `json:"name"`
				Prob float64 `json:"prob"`
			} `json:"subclasses"`
		} `json:"recognition_results"`
	} `json:"segmentation_results"`
}

var objmap []map[string]map[string][]interface{}

func PostFoodHandler(w http.ResponseWriter, r *http.Request) {

	r.ParseMultipartForm(10 << 20)

	file, _, err := r.FormFile("myFile")

	//authForLogMeal := r.FormValue("apiKeyLogMeal")
	//edamamAppId := r.FormValue("edamamAppId")
	//edamamAppKey := r.FormValue("edamamAppKey")

	if err != nil {
		log.Println("Error Retrieving the File")
		log.Println(err)
		return
	}

	defer file.Close()
	//fmt.Printf("File Size: %+v\n", handler.Size)
	//fmt.Printf("MIME Header: %+v\n", handler.Header)

	tempFile, err := ioutil.TempFile("uploads", "upload-*.jpg")
	if err != nil {
		log.Println(err)
	}
	defer tempFile.Close()

	fileBytes, err := ioutil.ReadAll(file)
	if err != nil {
		log.Println(err)
	}
	tempFile.Write(fileBytes)

	////APİ İŞLEMİ
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)

	// data, err := json.Marshal(call("https://api.logmeal.es/v2/image/segmentation/complete/v1.0", "POST"))
	// if err != nil {
	// 	log.Fatal(err)
	// }

	var foodData AutoGenerated

	//result = call("https://api.logmeal.es/v2/image/segmentation/complete/v1.0", "POST", tempFile.Name(), authForLogMeal)

	jsonFile, _ := os.Open("omlet.json")
	result, _ := ioutil.ReadAll(jsonFile)

	//var m map[string]map[string]interface{}

	if err := json.Unmarshal(result, &foodData); err != nil {
		panic(err)
	}
	ttt := foodData.SegmentationResults[0]
	//fmt.Println(ttt)
	Count := make(map[int]string)
	Count2 := make(map[int]float64)
	for k, v1 := range ttt.RecognitionResults {

		//kv := string line1 = str.Split(new [] { '\r', '\n' }).FirstOrDefault()

		//fmt.Println(string(v1.Name.Split(new [] { '\r', '\n' }).FirstOrDefault()))
		//fmt.Println(v1.Name)

		//kv := []string{}
		//countArray := []strs{}

		Count[k] = v1.Name
		Count2[k] = v1.Prob

		// for name, cnt := range Count {
		// 	countArray = append(countArray, strs{Name: name, Count: cnt})
		// }

		// res1 := strings.Split(v1.Name, "\n")
		// res1 = append(res1)

		// vs, _ := json.Marshal(v1.Name)
		// w.Write(vs)

	}

	//fmt.Println(Count[0])
	//foodName := Count[0]
	//foodProb := Count2[0]

	//w.Write()
	// time.AfterFunc(2*time.Second, func() {
	// 	w.Write(call("https://api.logmeal.es/v2/image/segmentation/complete/v1.0", "POST", tempFile.Name()))
	// })
	fmt.Println(Count2)
	//w.Write(callFinal(foodName, edamamAppId, edamamAppKey))

	//fmt.Println(handler.Filename)
}

func call(urlPath, method, namesFile, authForLogMeal string) []byte {
	client := &http.Client{
		Timeout: time.Second * 10,
	}

	// New multipart writer.
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	fw, err := writer.CreateFormFile("image", namesFile)
	if err != nil {
		fmt.Println(err)
	}
	file, err := os.Open(namesFile)
	if err != nil {
		fmt.Println(err)
	}
	_, err = io.Copy(fw, file)
	if err != nil {
		fmt.Println(err)
	}
	writer.Close()
	req, err := http.NewRequest(method, urlPath, bytes.NewReader(body.Bytes()))
	if err != nil {
		fmt.Println(err)
	}
	//d6f3fc37780263a9b79b3882f98c45e926aefe6f
	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.Header.Add("Authorization", "Bearer "+authForLogMeal+"")
	rsp, _ := client.Do(req)
	if rsp.StatusCode != http.StatusOK {
		log.Printf("Request failed with response code: %d", rsp.StatusCode)
	}
	//body, err := ioutil.ReadAll(res.Body)

	defer rsp.Body.Close()
	bodyss, _ := ioutil.ReadAll(rsp.Body) // response body is []byte
	return bodyss

}

func callFinal(foodName, id, key string) []byte {

	url := "https://api.edamam.com/api/food-database/v2/parser?app_id=" + id + "&app_key=" + key + "&ingr=" + foodName + "&nutrition-type=cooking"
	method := "GET"

	client := &http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}
	req, err := http.NewRequest(method, url, nil)

	if err != nil {
		fmt.Println(err)

	}
	req.Header.Add("Cookie", "route=e481a465d06c540d7b2608f57c42fdb2")

	res, err := client.Do(req)
	if err != nil {
		fmt.Println(err)

	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)

	}
	return body
}
